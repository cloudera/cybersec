options{  CHOICE_AMBIGUITY_CHECK = 3;  OTHER_AMBIGUITY_CHECK = 2;  //DEBUG_PARSER=true
  //DEBUG_LOOKAHEAD=true
  //DEBUG_TOKEN_MANAGER=true
  ERROR_REPORTING = true;  JAVA_UNICODE_ESCAPE = true;  UNICODE_INPUT = true;  IGNORE_CASE = true;  SUPPORT_CLASS_VISIBILITY_PUBLIC = false;  FORCE_LA_CHECK = true;  CACHE_TOKENS = true;  SANITY_CHECK = true;  STATIC = false;  //KEEP_LINE_COLUMN=true;
}PARSER_BEGIN(ISEParser)/** * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.metron.ise.parser;import java.io.*;import java.util.*;import org.json.simple.*;/**
* Basic ISE data parser generated by JavaCC.
*/public class ISEParser implements Serializable{  private boolean nativeNumbers = false;  public ISEParser()  { //do nothing
  }  public ISEParser(String input)  {    this (new StringReader(input));  }  /**
	* Parses a ISE String into a JSON object {@code Map}.
	*/  public JSONObject parseObject() throws ParseException  {    JSONObject toReturn = object();    if (!ensureEOF()) throw new IllegalStateException("Expected EOF, but still had content to parse");    return toReturn;  }}PARSER_END(ISEParser)// Ignore commentsSKIP :{  < C_SINGLE_COMMENT : "//" (~[ "\n", "\r", "\f" ])* < EOL >>| < C_MULTILINE_COMMENT : "/*" (~[ ])* "*/" >| < SH_SINGLE_COMMENT : "#" (~[ "\n", "\r", "\f" ])* < EOL >>  /*| < WHITESPACE :    " "  | "\t" >*/| < EOL :    "\n"  | "\r"  | "\f" >}// Common tokens
TOKEN :{  < COMMA : "," >| < EQUALS : "=" >| < SLASH : "\\" >| < TAG : "(tag=0)" >}// Null token/*TOKEN :{  //< NULL : "null" >}*/// String tokens
TOKEN :{  //< SYMBOL : ([ "a"-"z", "A"-"Z", "0", "1"-"9", " ", "\t" , ":" , "-" , "." ])+ >  < STRING_BODY :    (      (~[ "\"", "\r", "\n", "\f", "\t", "=", "," ])    |      (        "\\"        (          "r"        | "n"        | "f"        | "\\"        | "/"        | "\""        | "b"        | "t"        | ","        )      )    )+ >| < BRACED_STRING :    (      "{" (~[ "{", "}" ])+ "}"    ) >}boolean ensureEOF() :{}{  (< COMMA >)? < EOF >  {    return true;  }}JSONObject innerMap() :{  final JSONObject json = new JSONObject();  String key;  Object value;}{  key = objectKey() < EQUALS > value = value()  {    json.put(key, value);  }  {    key = null;    value = null;  }  (    < SLASH > < COMMA > key = objectKey() < EQUALS > value = value()    {      json.put(key, value);    }    {      key = null;      value = null;    }  )*  {    return json;  }}JSONObject object() :{  final JSONObject json = new JSONObject();  String key;  Object value;}{  key = objectKey() < EQUALS > value = value()  {    json.put(key, value);  }  {    key = null;    value = null;  }  (    (      LOOKAHEAD(2)      < COMMA > key = objectKey() < EQUALS > value = value()      {        json.put(key, value);      }      {        key = null;        value = null;      }    )*  | LOOKAHEAD(2)    < COMMA > < EOF >  )  // ensureEOF()  {    return json;  }}String objectKey() :{  String k;}{  (    k = string()  )  {    //  System.out.println("key == " + k);    return k.trim();  }}Object value() :{  Object x;  String eof = "EOF";  Map m = null;}{  (    LOOKAHEAD(< COMMA >)    x = nullValue()  | LOOKAHEAD(innerMap())    x = innerMap()  | x = tagString()  | LOOKAHEAD(< EOF >)    x = blankValue()  | LOOKAHEAD(braced_string())    x = braced_string()  | LOOKAHEAD(2)    x = string()  )  {    //  System.out.println("val == " + x);    //if (x instanceof Map) return "Map";    //return (String) x;    return x;  }}String nullValue() :{}{  {    return null;  }}String tagString() :{  String output = "(tag=0)";}{  < TAG > < STRING_BODY >  {    return output + token.image;  }}String blankValue() :{}{  {    return null;  }}String string() :{  String s;}{  < STRING_BODY >  {    return token.image.trim();  }}String braced_string() :{  String s;}{  < BRACED_STRING >  {    //  System.out.println("braced == " + token.image);    s = token.image;  }  < COMMA >  {    return s.trim();  }}